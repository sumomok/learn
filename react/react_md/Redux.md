# Redux核心概念

React-->ui解决方案

action reducer store

## MVC
他是一个ui的解决方案，用于降低UI，以及UI关联数据的复杂度

**传统的服务器端的MVC**

环境：
1. 服务端需要响应一个完整的html
2. 该html中包含页面需要的数据
3. 浏览器仅承担渲染页面的作用

以上的这种方式叫做**服务端渲染**，即服务器端将完整的页面组装好之后，一起发送给客户端。
服务器端需要处理ui中要用到的数据，并且要将数据嵌入到页面中，最终生成一个完整的html

为了解决这个问题的复杂度，出现了mvc架构

**contorller**:处理请求，组装这次请求需要的数据
**MODEL**：需要用于UI渲染的数据模型
**View**：视图，用于将模型组装到界面中

**前端MVC的模式的困难**

react 解决了 数据->视图的问题
但是 控制器->数据 难以解决（同一数据可能有不同的更改方式，不好更改的同时还不利于维护）
1. 前端的controller要比服务器情况复杂的多，因为前端中的controller处理的是用户的操作，而用户操作场景是复杂的
2. 对于组件化的框架（vue，react），它们使用的是单向数据流。若需要共享数据，则必须将数据提升到顶层，然后一层层的传递，这样会导致对数据的操作难以监控，容易导致调试错误的困难，以及数据还原的困难，并且，若开发一个大中型项目，共享的数据很多，会导致上下文中的数据编的非常复杂。


## 前端需要一个独立的数据解决方案
    用于降低数据复杂度

**Flux**

facebook提出的数据解决方案，它最大的历史意义，在于它引入action 充当一个交互和数据模型间的中间层，

action 就是一个普通对象，用于描述要干什么

示例：
```js
var action = {
    type:"login",
    payload:{
        loginId:"admin",
        password:"123"
    }
}
```
其中 type表明了 这个action要做什么，附带的数据是什么 （类似于定义接口，断开了与操作的耦合）

store 表示数据仓库，用于存储共享数据，还可以根据不同的action更改仓库中的数据

**Redux**

引入了 reducer 的概念  在 action 与 store 中间再加一层处理层 根据action来处理store中的数据，处理完毕之后 store再次存储结果

## Action

1. action 是一个plain-object 对象（平面对象）
    1. 他的__proto__指向Object.prototype (即直接赋值{}或者new object得到的对象)（通过其他构造函数形成的对象会报错）
2. action 必须有type属性，该属性用于描述操作类型
    1. type类型无要求
3. 通常,使用payload属性来表示附加属性（无强制要求）
4. 在大型项目中，由于操作类型非常多，为了避免硬编码（hard code 即 判断时写死的字符串 例：if(type === "set")其中"set"即为硬编码），会将action的类型存放到一个或者一些单独的文件中（样板代码）。
5. 为了方便传递action，通常会使用action创建函数（action createor）来创建action
    1. action创建函数应为无副作用的纯函数
        1. 不能以任何形式改动参数
        2. 不可有异步
        3. 不可以对外部环境中的数据造成影响
6. 为了方便利用action创建函数来分发（触发）action，redux提供了一个函数（bindActionCreators），该函数用于增强action创建函数的功能，使他不仅可以创建action，并且创建后悔自动完成分发