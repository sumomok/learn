# HOOK 简介

HOOK是React16.8.0之后出现

HOOK专门用于增强函数组件的功能（HOOK在类组件中是不能使用的），使之理论上可以成为类组件的替代品

官方强调：没有必要更改已经完成的类组件。官方目前没有计划取消类组件，只是鼓励使用函数组件

HOOK（钩子）本质上是一个函数（命名上总是以USE开头），该函数可以挂载任意的功能



# State HOOK
state Hook 是一个在函数组件中使用的函数（useState），用于在函数组件中使用状态

useState 
1. 函数有一个参数，这个参数的值表示状态的默认值
2. 函数的返回值是一个数组，该数组一定包含两项
    1. 第一项：当前状态的值
    2. 第二项：改变状态的函数
一个函数组件可以有多个状态，这种做法非常有利于横向切分关注点

## state Hook 原理
1. 当运行一个函数组件（调用该函数）
    1. 调用useState
    2. 检查该节点的状态
        1. 状态表格中无内容
        2. 使用默认值创建一个状态
        3. 将该状态加入到表格中


**注意的细节**

1. useState最好卸载函数的起始位置，便于阅读
2. useState严禁出现在代码块中（循环，判断。原因：useState对比数据的时候是按照创建的队列数组的序号对比，if或者for可能会改变比对顺序，造成不应该的数据修改，从而造成BUG）
3. useState返回的函数（数组第二项），引用是不变的（节约内存空间）
4. 使用函数改变数据，若数据和之前的数据完全相等（使用Object.is比较），不会导致重新渲染，以达到优化效率的目的。
5. 使用函数改变数据，传入的值不会和原来的数据进行合并而是直接替换。
6. 如果要实现强制刷新组建
    1. 类组件：使用forceUpdate函数
    2. 函数组件：使用一个空对象的useState
7. **如果某些状态之间没有必然的联系，应该分化为不同的状态，而不要合并成一个对象**（合并成一个对象，再修改时会造成不必要的渲染）
8. 和类组件的状态一样，函数组件中改变状态可能是异步的（在DOM事件中），多个状态变化会合并以提高效率，此时，不能新人之前的状态，而应该使用回调函数的方式改变状态。
``` js
    // 合并运行  只运行一次 也就是 n-1只运行一次
    <button
        onClick={()=>{
            setN(n - 1);
            setN(n - 1);
        }}
    ></button>

        // 用到上一次状态时用下面的方法
        <button
        onClick={()=>{
             setN(prve=>prve-1);
            setN(prve=>prve-1);
        }}
    ></button>
```



# Effect Hook
Effect Hook：用于在函数组件中处理副作用的

React推荐组件中不是副作用函数

副作用：
1. ajax请求 
2. 计时器
3. 其他异步操作
4. 更改真实的DOM对象
5. 本地存储
6. 其他会对外部产生影响的操作

函数：useEffect，该函数接受一个函数作为参数，接受的函数就是需要进行副作用操作的函数


**细节**

1. 副作用函数的运行时间点，是在页面完成真实的UI渲染之后。因此他的执行时异步的，并且不会阻塞浏览器
    与类组件中componentDidMount和componentDidUpdate的区别
    1. componentDidMount、componentDidUpdate更改了真实DOM，但是用户还没有看到UI更新
    2. useEffect中的副作用函数，更改了真实的DOM，并且用户已经看到了UI更新，异步的。
2. 每个函数组件中，可以多次使用useEffect，但不要放入判断或循环中（同useState）
3. useEffect中的副作用函数，可以有返回值，返回值必须是一个函数，该函数叫做清理函数
    1. 该函数运行时间点，在每次运行副作用函数之前
    2. 首次渲染组件不会运行
    3. 组件被销毁时一定会运行清理函数，不运行副作用函数
4. useEffect函数，可以传递第二个参数
    1. 第二个参数是一个数组
    2. 数组中记录该副作用的依赖数据
    3. 当组件重新渲染后，只有依赖数据与上次不一样的时候，才会执行副作用
    4. 所以，当传递了依赖数据之后，如果数据没有发生变化
        1. 副作用函数仅在第一次渲染后运行
        2. 清理函数仅在卸载组件后运行
5. 副作用函数中，如果使用了函数上下文中的变量，则由于闭包的影响，会导致副作用函数中变量不会实时变化
6. 副作用函数在每次注册时，会覆盖掉之前的副作用函数，因此，尽量保持副作用函数稳定，否则控制起来会比较复杂

```js
    useEffect(n===1?fun1:fun2) //这种情况下回出现上述问题
```

# 自定义HOOK

State Hook：useState
Effect Hook ：useEffect

自定义Hook：将一些常用的，跨越多个组件的Hook功能，抽离出去形成一个函数，该函数就是自定义Hook
命名：自定义Hook，由于内部需要使用Hook功能，所以它本身也需要按照Hook的规则实现：
1. 函数名必须以use开头
2. 调用自定义Hook函数时，应该放到顶层

例如：

1. 很多组件都需要在第一次加载完成后，获取数据


# callBack

返回一个地址固定的函数

# Memo Hook

将一些高开销的计算放到其中，依赖项不发生变话就不会重新计算，用于保持一些比较稳定的数据，通常用于性能优化

# Ref HOOK
useRef函数：
1. 一个参数：默认值
2. 返回一个规定的对象 ```{current:
值}```
3. 产生一个唯一的对象来接受数据（常用于创建一个ref，获取真实的dom对象）
# ImperativeHandle HOOK

React不希望命令式的方法（直接调用类组件中的方法）

函数：useImperativeHandle

返回一个规定的对象
{
    current: 函数的返回值
}

# LayoutEffect HOOK

函数：useLayoutEffect
同类组件中的 componentDidMount和componentDidUpdate，都是真正的dom已经发生改动了，但是用户还没有看到UI更新
而useEffect 是用户已经看到dom更新了之后的操作

# DebugValue Hook

useDebugValue:用于将自定义Hook的关联数据显示到调试栏

如果创建的自定义Hook通用性比较高可以用这个来提示，方便在浏览器React插件中调试