<!--
 * @Author: your name
 * @Date: 2020-03-19 14:02:14
 * @LastEditTime: 2020-03-19 17:46:39
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \learn\typeScript\lession1.md
 -->

# 在 node中搭建ts开发环境

## 安装typescript
    npm/cnpm install -g typescript

默认情况下，ts会做出下面几种假设：
1. 假设当前的执行环境是dom
2. 如果代码中没有使用模块化语句，认为该代码是全局执行
3. 编译目标代码是es3

有两种方式更改以上假设

1. 在命令行后 加上相关参数
2. 使用ts配置文件，更改编译选项

# ts的配置文件

使用配置文件后，使用tsc进行编译时，不能跟上文件名，否则会忽略配置文件。
@types/node
@types 是一个官方的类型库，对于很多已有的js依赖进行类型描述

# 使用第三方库简化流程

ts-node：可以简化 编译流程，使其在内存中编译完成并运行 （ts-node 不生成编译后的文件，在内存中编译完毕后直接运行）

nodemon :检测文件变化，并执行相应命令 (--watch 文件目录 指只监听配置的文件目录  -e 文件后缀名 指只监听该文件后缀名的文件 )

# 基本类型约束
> TS是一个可选的静态类型约束系统

## 如果进行类型约束

仅需要在变量，函数的参数，函数的返回值位置后加冒号和类型约束即可

## 源代码和编译结果的差异

除了类型去掉，其他没有任何变化

## 基本类型

- number
- string
- boolean 
- object
- array
- null 和 undefined

null和undefined是其他类型的子类型,在配置中未配置strict时可以赋值给其他任何类型的变量

想要避免这种情况，在配置中添加strictNullChecks:true即可

strict 是开启所有严格模式


# 常用类型

- 联合类型 多种类型任选其一

配合类型保护进行判断

类型保护:当对某个变量进行类型判断之后，在判断的语句块中便可以确定他的确切类型，typeof可以出发类型保护。

- void类型：通常用于约束函数的返回值，表示该函数没有任何的返回

- never  表示函数永远不可能结束

- 字面量取值 ：约束为某一个值 表示某个变量只能为一个某一个值，
- 元祖：约束一个数组为固定长度，内容固定
- any类型：any类型可以绕过类型检查，any类型的数据可以赋值给任意类型  不能随意使用

# 函数相关约束

函数重载： 在一个函数声明上面提供这个函数的传参情况，ts会识别
如下例子

```js
function test(a:number,b:number):number
function test(a:string,b:string):string
function test(a:string|number,b:string|number):string|number {
    if (typeof a === 'string' && typeof b==="string"){
        return a + b
    } else if (typeof a === 'number' && typeof b==="number"){
        return a+ b
    }
}


```

# 扩展类型-枚举（场景大量使用需要约束的地方）
> 扩展类型 ：类型别名、枚举、接口、类

枚举通常用于约束某个变量的取值范围。

字面量和联合类型配合使用，也可以达到同样的效果

但**字面量类型的问题**

- 在类型约束位置，会产生重复代码。可以使用类型别名解决该问题。
- 逻辑名称和真是的值产生了混淆，会导致当修改真实值的时候，干声大量的修改。
- 字面量类型不会进入到编译结果中

# 枚举

如何定义一个枚举

```ts
enum test{
    //枚举字段1 = 值1
    //枚举字段2 = 值2
}
```

枚举会出现在编译结果中，编译结果中表现为对象

枚举的规则：

- 枚举的字段值可以是字符串或数字
- 数字枚举的值会自动自增
- 被数字枚举约束的变量，可以直接赋值为数字（不推荐使用，尽量用逻辑名）
- 数字枚举的便宜结果和字符串枚举有差异

最佳实践：
 - 尽量不要在一个枚举中即出现字符串字段，又出现数字字段（不能这样干）
 - 使用枚举时，尽量使用枚举字段的名称，尽量不要使用真实的值


 ## 扩展知识：位枚举（枚举的位运算）

针对数字枚举


# 模块化

配置：
module：设置编译结果使用的模块化标准
moduleResolution：设置解析模块的模式
noImplicituserStrict 编译结果中不含有 use strict
removeComments 编译结果移除注释
noEmitOnError错误时不生成编译结果
esModuleInterop 启用es模块化交互非Es模块到处

>   前端领域中的模块化标准：Es6 commonjs amd umd system esnext
>   ts中如何书写模块化语句  ES6标准

# 接口和类型兼容性

# 扩展类型-接口

> 扩展类型：类型别名、枚举、接口、类

typescript的接口：用于约束类、对象、函数的契约

契约标准的形式：
- API文档，弱标准
- 代码约束，强标准

1. 接口约束对象
    接口和类型别名一样，编译后消失
    1. 定义一个接口
    ```ts
    interface User{
        name:string,
        age:number
    }
    ```
    2. 接口可以约束函数

**接口可以继承**

可以通过接口之间的继承，实现多种接口的组合

使用类型别名可以实现类似的组合效果，需要通过```&```，它叫做交叉类型

它们的区别：
- 子接口不能覆盖父接口的成员
- 交叉类型会把相同的成员的类型进行交叉

**readonly**

只读修饰符,只能在开始进行赋值,其他无法更改,对于数组而言 修饰类型的情况下 ``` 在已经给定数组的情况下 会拒绝所有的修改自己的操作包括:push,pop,shift,unshift等,但是重新给变量赋值未限制(可以用const处理这个问题)

**属性**
使用属性列表来描述类中的属性

**属性的初始化检查**

strictPropertyInitialization 配置设为true 为严格

**属性简写**

 在constructor的参数中加入修饰符（public等）即可以定义一个从参数中赋值的类属性，是个语法糖

# 泛型

有时候，书写某个函数时，会丢失一些信息，导致无法运用Ts带来的便利

泛型：是指附属于函数、类、接口、类型别名之上的类型

泛型相当于是一个类型变量，在定义时，无法预先知道具体的类型，在使用的时候将该类型传入，确保所有使用泛型的类型一致

TS会智能推倒泛型是什么类型，如果没有传递具体的类型，默认为空对象类型

# 在函数中使用泛型
在函数名之后写上```<泛型名称>``` 泛型可以设置默认值 ```<泛型名称 = 默认类型>```
# 在类中使用泛型

在类名后面使用```<泛型名称>```  在整个类中可以使用该泛型

# 泛型的约束
泛型约束，可以约束泛型的取值，可以先定义一个接口，然后让泛型继承接口

# 多泛型

```<泛型名称1，泛型名称2，。。。。>```


#总结

typescript是可选的、静态的类型系统

为什么需要类型系统？

要构建大型应用时，会涉及大量的函数和接口，如果没有类型检查，会产生大量的调试成本。类型系统可以降低调试成本，从而降低开发成本

-可选的

TS是JS的超集，js的所有功能都能够在TS中使用，增加的部分是类型系统。

-静态的

TS代码->编译->JS代码

# 如何约束类型

变量，参数，函数返回值，类

- 基本类型：boolean number string object array void（js中表示任意表达式返回undefined） never （永远不会结束） null undefined
- 扩展类型：类型别名、枚举、接口、类

类型接口、接口、不产生编译结构
枚举、类 产生编译结果 枚举->编译->对象 TS类->JS类

TS类：属性列表、修饰符（readonly）访问修饰符（public、private、protected）

泛型：接触某个功能和类型的耦合


类型断言：开发者非常清楚某个东西的类型，但是TS难以分辨，开发者可以通过类型断言，告诉TS对象类型

# 类型兼容性

鸭子辩型法，子结构辩型法。
- 基本类型：完全匹配
- 对象类型：鸭子辩型法，字面量对象直接传递时，会有更严格的类型检查
- 函数类型：参数数量可以少，但不可以多。要求返回必须返回，不要求返回，就随便